
# This file:
# - /inc/analyze.py (UTF-8/LF/4 SP)
#
# By: agnosis.be
# Repo: gabc
# File version: 1.0
#
# Provides:
# - class Analyzer
# - class OutOfBounds(Exception)
# - class InvalidArguments(Exception)
# - class NoResults(Exception)
# - class UnknownOutputFormat(Exception)

import pandas as pd # pip install pandas
from pandas.core.frame import DataFrame
import numpy as np
from string import ascii_lowercase
from datetime import datetime, timezone
import os

class GabcException(Exception):
    pass

class OutOfBounds(GabcException):
    pass

class InvalidArguments(GabcException):
    pass

class NoResults(GabcException):
    pass

class UnknownOutputFormat(GabcException):
    pass

class Analyzer:
    """
    Provider of functions to analyze aggregated data

    For usage see:
    - ../rc/do_get_abc.py <-- Caller

    For class Consolidator see:
    - ./consolidate.py <-- Generates input_file
    """

    input_dir = '../data/consolidated'
    input_enc = 'utf-8'
    input_sep = '|'

    output_dir = '../data/analyzed'
    output_enc = 'utf-8'

    input_file = ''
    df = DataFrame()

    def __init__(self, input_file: str):
        """
        Construct Analyzer with input_file generated by Consolidator

        """
        self.input_file = input_file
        self.input_path = "{}/{}".format(self.input_dir, self.input_file)

    def get_abc(self, *,
                dates: slice = slice(None),
                clients: slice = slice(None),
                langs: slice = slice(None),
                ranks: slice = slice(None)) -> dict:
        """
        For every letter from a to z get G**gle's top suggest term for that letter incl. its frequency

        Sample output (of type DataFrame):
          a amazon 365
          b bild 328
          c check24 156
        """

        # Check arguments
        if self._has_start_and_stop_or_none(dates) \
          and self._has_start_and_stop_or_none(clients) \
          and self._has_start_and_stop_or_none(langs) \
          and self._has_start_and_stop_or_none(ranks):
            pass
        else:
            raise InvalidArguments("Always provide start and stop for each parameter (unless None)")

        abc_dict = {
            'result' : {},
            'meta' : {}
        }

        # Load data set
        self._init_df()

        # Check bounds
        self._check_bounds(dates, clients, langs, ranks)

        # Filter data set with arguments
        idxs = pd.IndexSlice[dates, clients, langs, :, ranks]
        df2 = self.df.loc[idxs, :]

        _result = {}

        # From a to z ...
        for letter in ascii_lowercase:
            # ... filter with current letter
            idxs_letter = pd.IndexSlice[:, :, :, letter, :]
            try:
                df3 = df2.loc[idxs_letter, ['term']]
            except KeyError:
                raise KeyError("Letter {} not in filtered data set".format(letter))

            # ... get statistics on column 'term'
            result_ser = df3['term'].describe()
            _result[letter] = [result_ser['top'], result_ser['freq']]

        # Convert to DataFrame
        df_result = pd.DataFrame.from_dict(data=_result, orient='index', columns=['term', 'freq'])
        df_result.index.name = 'letter'

        # Check if there are results
        nulls_ser = df_result.isnull().all()
        if nulls_ser['term'] == True and nulls_ser['freq'] == True:
            raise NoResults('No result with given arguments')

        abc_dict['result'] = df_result

        # Get nulls in filtered data set
        df_nulls = self.get_nulls(dates=dates, clients=clients, langs=langs, ranks=ranks)

        # Store meta data
        _meta = {
            'function_used' : 'Analyzer.get_abc',
            'output_generated_on' : datetime.now(tz=timezone.utc).isoformat(timespec='seconds'),
            'input_file' : self.input_file,
            'has_missing_values' : 'yes' if len(df_nulls) > 0 else 'no',
            'args_dates' : "{},{}".format(dates.start, dates.stop),
            'args_clients' : "{},{}".format(clients.start, clients.stop),
            'args_langs' : "{},{}".format(langs.start, langs.stop),
            'args_ranks' : "{},{}".format(ranks.start, ranks.stop)
        }

        # Convert to DataFrame
        df_meta = pd.DataFrame.from_dict(data=_meta, orient='index', columns=['value'])
        df_meta.index.name = 'key'
        abc_dict['meta'] = df_meta

        return abc_dict

    def get_nulls(self, *,
                dates: slice = slice(None),
                clients: slice = slice(None),
                langs: slice = slice(None),
                ranks: slice = slice(None)) -> DataFrame:
        """
        Get missing values
        """

        # Load data set
        self._init_df()

        # Filter data set with arguments
        idxs = pd.IndexSlice[dates, clients, langs, :, ranks]
        df2 = self.df.loc[idxs, :]

        # Filter df2 on nulls
        null_filter = df2.isnull().any(axis=1)
        df3 = df2.loc[null_filter, :]
        return df3

    def get_stats(self, *,
                dates: slice = slice(None),
                clients: slice = slice(None),
                langs: slice = slice(None),
                ranks: slice = slice(None)) -> DataFrame:
        """
        Get statistics on current data set

        Returns:
        - date_min
        - date_max
        - clients
        - langs
        - ranks
        """

        # Load data set
        self._init_df()

        # Filter data set with arguments
        idxs = pd.IndexSlice[dates, clients, langs, :, ranks]
        df2 = self.df.loc[idxs, :]

        # Drop nulls
        df3 = df2.dropna()

        ranks = list(df3['rank'].unique())
        ranks = list(map(int, ranks))
        ranks.sort()

        clients = list(df3['client'].unique())
        clients.sort()

        _stats = {
            'date_min' : str(df3['date'].min())[0:10],
            'date_max' : str(df3['date'].max())[0:10],
            'langs' : ','.join(list(df3['lang'].unique())),
            'ranks' : ','.join(map(str, ranks)),
            'clients' : ','.join(clients)
        }

        # Convert to DataFrame
        df_stats = pd.DataFrame.from_dict(data=_stats, orient='index', columns=['value'])
        df_stats.index.name = 'key'

        return df_stats

    def args_to_string(self, *,
                dates: slice, clients: slice, langs: slice, ranks: slice) -> str:
        """
        Create string from arguments
        """
        return "{}-{}_{}-{}_{}-{}_{}-{}".format(
            dates.start,
            dates.stop,
            clients.start,
            clients.stop,
            langs.start,
            langs.stop,
            ranks.start,
            ranks.stop
        )

    def save_result(self, *,
                     result_dict: dict, output_format: str, user_name: str, function_used: str, dates: slice, clients: slice, langs: slice, ranks: slice) -> None:
        """
        Save result returned by analytical function to disk
        """

        # Prepare paths
        args = self.args_to_string(dates=dates, clients=clients, langs=langs, ranks=ranks)
        path_fmt = "{}/{}_{}_{}_{{}}.{}".format(self.output_dir, user_name, function_used, args, output_format)
        path_dict = {
            'result': path_fmt.format('result'),
            'meta': path_fmt.format('meta'),
            'nulls': path_fmt.format('nulls')
        }

        # Check
        if output_format != 'htm':
           raise UnknownOutputFormat("Unknown output_format {}".format(output_format))

        for key, path in path_dict.items():
            if os.path.isfile(path):
                raise FileExistsError("Already exists {}".format(path))

        # Save
        for key, path in path_dict.items():
            if key == 'nulls':
                if result_dict['meta'].loc['has_missing_values', 'value'] == 'yes':
                    df_nulls = self.get_nulls(dates=dates, clients=clients, langs=langs, ranks=ranks)
                    df_nulls.to_html(path, index_names=False, encoding=self.output_enc)
            else:
                result_dict[key].to_html(path, index_names=False, encoding=self.output_enc)

    def _init_df(self) -> None:
        """
        Load data set into DataFrame and create index entries for missing values
        """
        if self.df.index.empty:
            # Do this only once
            dtype = {'rank': np.int8}
            df: DataFrame = pd.read_csv(
                self.input_path,
                encoding=self.input_enc,
                sep=self.input_sep,
                header=0,
                dtype=dtype,
                date_format="%d.%m.%Y",
                parse_dates=['date']
            )

            # Set index
            df.set_index(['date', 'client', 'lang', 'letter', 'rank'], inplace=True, drop=False)

            # Reindex using cartesian product of existing values
            # to create index entries for missing values
            idx = pd.MultiIndex.from_product(df.index.levels)
            self.df = df.reindex(idx)

    def _has_start_and_stop_or_none(self, slc: slice) -> bool:
        """
        Verify that arguments of type slice have start and stop values (unless none)
        """
        if slc.start != None or slc.stop != None:
            return slc.start != None and slc.stop != None
        else:
            return True

    def _check_bounds(self, dates, clients, langs, ranks) -> None:
        """
        Check if arguments of analytical function are not out of bounds

        Call this function after self._has_start_and_stop_or_none()
        """

        # Get stats on unfiltered data set
        stats_df = self.get_stats()
        date_min = stats_df.loc['date_min', 'value']
        date_max = stats_df.loc['date_max', 'value']
        client_list = stats_df.loc['clients', 'value'].split(',')
        lang_list = stats_df.loc['langs', 'value'].split(',')
        rank_list = list(map(int, stats_df.loc['ranks', 'value'].split(',')))

        if dates.start != None and dates.start < date_min:
            raise OutOfBounds(
                "dates.start {} is less than date_min {} in input_file {}".format(
                    dates.start,
                    date_min,
                    self.input_file
                )
            )

        elif dates.stop != None and dates.stop > date_max:
            raise OutOfBounds(
                "dates.stop {} is greater than date_max {} in input_file {}".format(
                    dates.stop,
                    date_max,
                    self.input_file
                )
            )

        elif clients.start != None and clients.start not in client_list:
            raise OutOfBounds(
                "client.start {} is not contained in input_file {}".format(
                    clients.start,
                    self.input_file
                )
            )

        elif langs.start != None and langs.start not in lang_list:
            raise OutOfBounds(
                "langs.start {} is not contained in input_file {}".format(
                    langs.start,
                    self.input_file
                )
            )

        elif ranks.start != None and ranks.start not in rank_list:
            raise OutOfBounds(
                "ranks.start {} is not contained in input_file {}".format(
                    ranks.start,
                    self.input_file
                )
            )

        else:
            pass
